package MyIO

// The IO Monad takes a by-name parameter, representing `unsafe` code with side-effects
// For that reason, this cannot be a case class, as it cannot have by-name parameters
// Thus, we need to make the constructor `private`
class MyIOMonad[A] private (constructorCodeBlock: => A) {

  def code: A = this.constructorCodeBlock

  def flatMapExplained[B](someAlgorithm: A => MyIOMonad[B]): MyIOMonad[B]= {
    // Calling someAlgorithm on the constructorCodeBlock of THIS IO monad instance, generates IO-wrapped code output
    val wrappedCode: MyIOMonad[B] = someAlgorithm(this.code)
    // get wrappedCode from IO monad instance generated by someAlgorithm and wrap it again into a new IO monad instance
    new MyIOMonad[B](constructorCodeBlock = wrappedCode.code)
  }

  def flatMap[B](f: A => MyIOMonad[B]): MyIOMonad[B] = MyIOMonad(f(code).code)

  def map[B](f: A => B): MyIOMonad[B] = flatMap(unwrappedCode => MyIOMonad(f(unwrappedCode)))
}

// We'll need the `lift` operation to construct the `map` method in the MyIOMonad class
object MyIOMonad {
  def apply[A](nakedCode: A): MyIOMonad[A] = new MyIOMonad[A](constructorCodeBlock = nakedCode)
}

object IODriver extends App {

  // define input and output functions, returning side-effect  code wrapped inside of a MyIOMonad instance
  def getLine: MyIOMonad[String] = MyIOMonad(scala.io.StdIn.readLine())
  def putLine(line: String): MyIOMonad[Unit] = MyIOMonad(println(line))

//  val chainedIOCode: MyIOMonad[Unit] = for {
//    _ <- putLine("Write something, please!")
//    firstLine <- getLine
//    _ <- putLine(s"You wrote - $firstLine")
//
//  } yield ()

  // rewrite for-comp in unwrapped form
  val firstIOCode: MyIOMonad[Unit] = putLine("Write something, please!")
  firstIOCode.flatMap( _ => getLine.map(lineUserPutIn => putLine(line=s"You put in the line - $lineUserPutIn")))

}
